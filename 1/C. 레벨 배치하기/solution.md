
조건 1,2로부터 시작 레벨에서 진행가능한 레벨 배치들을 순서대로 쭉 나열하면 N개의 노드로 구성된 트리가 구성된다는 것을 알 수 있다. 따라서, 이 문제는 주어진 레벨들을 이용해 조건을 만족하는 트리를 몇 개나 구성할 수 있는지를 물어보는 문제로 생각할 수 있다.

또, 조건 5에 의해 트리상의 부모로부터 자식으로 향하는 모든 경로는 반드시 Si값이 증가하는 방향으로 진행해야 하므로, 루트 노드는 반드시 전체 레벨중 Si값이 가장 작은 레벨이 되어야 한다.

이제 Si값이 작은 레벨부터 시작해서 각 레벨에 대해 그 레벨보다 앞에 클리어해야 하는 레벨(부모 노드)을 뭘로 정해야 하는지만 결정해주면 된다. 왜냐하면, Si가 항상 증가하는 방향으로만 이동해야하기 때문에 특정 레벨의 부모 노드는 자신보다 더 Si값이 작은 레벨일 수 밖에 없고, 따라서 Si가 제일 작은 노드부터 순서대로 그 부모를 정해주는 것은 루트 노드에서 자식들을 조건을 만족하게 하나씩 붙여나가면서 트리를 구성하는 것과 마찬가지가 되기 때문이다.

이 때 각 노드에 대해 그 노드의 부모 노드는 자신보다 Si가 작은 노드 중 Kj = Ki - Si인 어느 노드라도 상관 없고, 이러한 노드의 개수는 map등의 자료구조로 관리하면 O(logn)으로 쉽게 찾을 수 있다. 이를 이용해 각 노드(레벨)에 대해 그 레벨의 부모 노드가 될 수 있는 노드의 개수를 구한 후, 그 개수를 전부 곱해주면 답을 구할 수 있다.

왜냐하면, 어떤 노드에 대해 그 노드가 붙을 수 있는 위치는 오로지 그 부모 노드의 Ki값과 Si값에 의해 결정되고, 그 부모 노드 위에 무슨 노드가 있는 지는 해당 노드의 위치를 결정하는 것에 전혀 영향을 끼치지 않으며, 특정 노드 i에 대해 해당 노드를 제외한 나머지 노드들이 어떤 모양의 트리를 구성하고 있는가는 그 노드가 붙을 위치에 전혀 영향을 끼치지 않기 때문이다. 따라서 (현재까지 만들어진 트리의 경우의 수) * (각 트리에서 현재 노드를 붙일 수 있는 경우의 수)가 전체 트리를 만들 수 있는 경우의 수가 되고, 이는 결국 각 노드에 대해 그 노드가 붙을 수 있는 부모의 경우의 수를 구한 다음 모두 곱한 것과 동일한 값이 된다.

따라서, 정렬에 O(nlogn), 각 노드에 대해 붙을 수 있는 노드 개수를 구할 때 O(nlogn), 전체 경우의 수를 구할 때 O(n)의 시간이 필요하므로 전체 시간 복잡도는 O(nlogn)이 된다.