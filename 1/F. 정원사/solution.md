모든 식물은 하루에 k씩 자라기 때문에 모든 값을 관리하려면 시간복잡도가 벌써 O(M^2)이 된다. 즉, 식물의 높이를 관리할 효율적인 방법을 찾아야 한다. 조금 엉뚱한 생각이지만, N개의 정원이 모두 거대한 엘리베이터 안에 있다고 생각해 보자. 이 엘리베이터는 식물이 자라는 속도와 반대로 하루에 k만큼 아래로 내려간다. 이렇게 되면 모든 식물의 절대적 높이는 변하지 않고, 온조가 뽑는 식물들의 높이의 기준만 내려간다. 즉, 식물들의 키가 변하는 값을 관리하지 않아도 되고, 온조가 식물을 뽑는 기준값만 변화시켜주면 되는 것이다. t번째 날에 높이 h의 식물을 심었다면 이 식물의 높이는 계속 h - tk가 되는 것이다. t번째 날에 높이 h 초과의 식물들을 뽑기로 했다면 높이가 h - tk 초과인 식물들을 뽑아주면 된다.  

이제 1번째 정원부터 N번째 정원 순으로 각각의 식물들이 얼마 동안 정원에 심어져 있는지를 계산할 것이다. 1번째 정원에 심어지는 식물들은 l <= 1 && 1 <= r인 2번 쿼리들에만 영향을 받게 된다. 최소값을 저장하는 세그먼트 트리에 조건을 만족하는 2번 쿼리들만 시간이 증가하는 순으로 높이 h - tk를 저장해준다. 이때 각각의 식물들이 얼마 동안 정원에 심어져 있는지 계산하는 문제는, (h_j - t_j X k) > (h_i - t_i X k) && t_i > t_j를 만족하는 가장 작은 i를 찾는 것과 같다. (j는 현재 계산하는 식물의 번호이다.) 이것은 최소값을 저장하는 세그먼트 트리로 O(logM)만에 해결할 수 있다. 이제 2번째 정원으로 넘어갈 때, 조건에 맞게 되는(l <= 2 && 2 <= r) 2번째 쿼리들을 세그먼트 트리에 추가해 준다. 또 반대로 조건에 더 이상 맞게 되지 않는 2번째 쿼리들을 세그먼트 트리에서 빼줘야 한다. 이는 세그먼트 트리의 업데이트 연산으로 역시 O(logM)에 할 수 있다. 이제 같은 과정을 반복하면 모든 정원의 식물들의 답을 계산할 수 있다.  

모든 식물에 대해 얼마 동안 정원에 심어져 있는지 O(MlogM)만에 알게 되었다. 이제 이 정보들을 이용해 3번째 쿼리들에 대한 답을 펜윅 트리와 같은 자료구조로 적절히 처리하면 답을 구할 수 있다.  

총 시간복잡도는 O(MlogM)이다.  

Sqrt Decomposition은 시간초과에 걸리도록, PST나 머지 소트 트리는 메모리 제한에 걸리도록 했다.  
