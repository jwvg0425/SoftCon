빈 문자열에서 연산 F를 두 번 적용해서 길이가 N인 문자열 S를 만들어야 하는데, 이 때 주어진 연산 A,B는 문자열의 길이를 +1, C는 문자열의 길이를 *2해준다.

그러면 문자열 길이 관점에서 F를 두 번 적용했을 때 길이 N을 만들기 위해 어떻게 해야 하는지 따져보자.

C연산을 쓰지 않는 경우는 간단히 전체 문자열이 중앙 절반을 기준으로 왼쪽 오른쪽이 동일한 문자열이면 길이가 N/2인 연산 F를 만들 수 있고 아니라면 불가능하므로 쉽게 판단할 수 있다.

연산 F에 C가 포함되는 경우는, 해당 연산 F를 C가 나오는 위치를 기준으로 나눠서 생각해보면,

Ki = 연산 F에서 i-1번째 C와 i번째 C사이에 존재하는 A,B 연산의 개수라고 하자.(단, C연산 개수가 c개일 때 K0와 Kc는 각각 문자열의 맨처음부터 첫번째 C까지 A,B 개수, 맨마지막 C부터 문자열 끝까지 A,B 개수)

예를 들어 연산 F = ABCCBCACAA 라고 하면 K0 = 2, K1 = 0, K2 = 1, K3 = 1, K4 = 2가 된다.

이렇게 뒀을 때, C연산의 개수가 c개인 연산 F를 빈 문자열에 적용했을 때 문자열의 길이 L은

L = K0 * 2^c + K1 * 2^(c-1) + K2 * 2^(c-2) + ... + Kc가 된다.

똑같은 방식으로 길이 L의 문자열에 한 번더 같은 연산 F를 적용하면 길이 N이 되어야 하는데, 위와 동일한 방식으로 식을 풀어 쓰면 다음과 같다.

N = L * 2^c + K0 * 2^c + K1 * 2^(c-1) + ... + Kc

L*2^c 뒷 부분은 L과 동일한 값이므로,

N = L * (2^c + 1)

따라서, 사용된 C 연산의 개수 c에 대해 N이 2^c + 1의 배수일 때만 조건을 만족하는 연산 F가 정의될 수 있다. 또 위 식으로부터 연산 F를 한 번 적용했을 때 문자열의 길이 L도 같이 구할 수 있다.

이제 C연산이 c개 사용됐을 때의 각 케이스에 대해 연산 F를 한 번 적용하면 길이 L이 되고 두번 적용하면 길이 N인 문자열 S가 되는 연산 F를 찾으면 된다.

이 때 F에 포함된 각 연산이 처음 적용될 때 영향을 끼칠 문자열 상의 위치 a와 두번째 적용될 때 영향을 끼칠 문자열 상의 위치 b를 묶어서 `(a,b)`로 나타내보자. 예를 들어 F의 맨 첫 번째 연산이 적용되는 위치는 `(0,L)`이 된다.

처음 적용될 때 문자열의 제일 첫번째 칸에 문자를 추가하게 될 것이고, 두번째 적용될 때는 0~L-1까지 길이의 문자열이 만들어진 상태에서 L번째 문자를 추가하게 될 것이기 때문이다.

따라서 연산 A혹은 B를 F에 포함시켰을 때 다음 연산이 실행될 위치는 `(a+1,b+1)`이 되고, C를 포함시키는 경우 다음 연산이 실행될 위치는 `(a*2,b*2)`가 된다.

또 조건에 따라, `(a,b)` 위치에서 연산 A혹은 B를 적용시키기 위해서는 문자열 S에서 `S[a] == S[b]`여야 한다. 또, `(a,b)` 위치에서 연산 C를 적용시키기 위해서는 S의 부분 문자열에 대해 `S[0..a-1] == S[a..2*a-1] && S[0..b-1] == S[b..2*b-1]` 여야 한다.

따라서 각각의 위치 `(a,b)`를 하나의 정점, 각 정점에서 조건을 만족해서 연산을 추가할 수 있는 경우 해당 위치간의 간선이 있는 것으로 생각하면 `(0,L)`에서 `(L,N)`으로의 최단거리를 구하는 것과 동일한 문제가 된다. 이는 BFS로 쉽게 구할 수 있고, 상태 값이 항상 a,b 모두 1씩 증가하거나 2배씩 증가하기 때문에 계산해보면 탐색해야할 정점의 개수가 그렇게 많지 않아 단순한 BFS로도 시간안에 구할 수 있다.

이 때, 연산 C를 적용시키는 조건 `S[0..a-1] == S[a..2*a-1] && S[0..b-1] == S[b..2*b-1]`를 빠르게 계산할 수 있어야 하는데, 이는 Z-algorithm을 이용해서 O(N) 시간에 구할 수 있다. Z-algorithm을 통해 만들어지는 배열 

z[i] = 문자열의 i번째 위치에서 시작하는 prefix중 문자열의 0번째 위치에서 시작하는 prefix와 일치하는 최대 길이 

이기 때문에, S[0..a-1] == S[a..2*a-1]라면 z[a] >= a이다. 이 조건을 이용하여 테이블을 O(N)에 전처리해두면 앞의 조건 `S[0..a-1] == S[a..2*a-1] && S[0..b-1] == S[b..2*b-1]`은 O(1)에 계산 가능하다.

### DP를 이용한 풀이

실제 대회에서는 정해와 다르게 푸신 분들이 모두 DP를 이용해서 풀었는데, 이 방법이 더 빠르고 좋은 풀이라 이 방법도 정리해 둔다.

N = L * (2^c +1) 공식을 유도해서 사용하는 것은 같으나, 여기서 최소 연산 개수를 구할 때 이용하는 상태 정의가 다르다. 위의 공식을 통해 사용할 전체 C연산의 개수 c를 고정해둔 상태에서, 아래 함수를 정의한다.

minOp(a, k) = 전체 문자열의 맨 앞 k글자를 만들기 위해 C연산을 a개 사용했을 때 필요한 최소 연산 개수(a <= c)

이렇게 정의할 경우, 맨 앞 k글자를 만들기 위해 C연산을 a개 사용했으므로, 두 번째로 연산이 적용될 때 문자열의 길이는 L*(2^a) + k가 된다. 따라서 이 공식을 이용해서 위의 BFS와 유사한 방식으로 특정 연산을 적용할 수 있는지 아닌지 판별할 수 있다.

즉, minOp 함수는 아래와 같은 점화식을 갖게 된다.

minOp(a,k) = 1 + min(minOp(a,k-1), minOp(a-1,k/2))

물론 이 때, A,B 연산을 적용하려면 `str[k-1] == str[L*(2^a)+k-1]`여야하고 C연산을 적용하려면 `str[0..k-1]`과 `str[0..L*(2^a)+k-1]`이 앞 절반과 뒤 절반이 동일한 문자열로 구성되어 있어야한다. 이 조건에 따라 위의 재귀식을 DP로 구성하면 전체 사용될 C 연산의 개수가 고정되어 있을 때 O(N)의 시간에 답을 구할 수 있다.